<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>The House Robber Problem</title>
	<link rel="stylesheet" type="text/css" href="Resources/animate.css"/>
	<style>
		body{
		margin: 0;
		padding: 0;
		background-image: url(Resources/bg.png);
		background-attachment: fixed;
		background-position: center;
		}
		header, footer {
			background: radial-gradient(circle, rgb(0,101,159), rgb(0,111,169), rgb(0,121,179), rgb(6,131,189), rgb(16,141,199), rgb(26,151,209), rgb(36,161,219), rgb(46,171,229), rgb(56,181,239));
			width: 100%;
			height: 80px;
			position: fixed;
		}
		header {
			top: 0;
		}
		footer {
			bottom: 0;
		}
		div .calc {
			margin: auto;
			width: 80%;
			border: 4px solid black;
			background-color: rgba(0,0,0,0.4);
		}
		canvas {
			border: 2px solid black;
		}
		p, ul, ol {
			line-height: 1.5;
			color: white;
			margin-top: 0; 
			margin-left: 100px; 
			margin-right: 100px; 
			text-align: justify; 
			font-size: 16pt; 
			text-indent: 1.25em
		}
		img {
			margin-left: 10%;
			margin-bottom: 10px;
			width: 80%; 
			border: 4px solid black;
		}
	</style>
</head>
<body>
	<header><span style="width: 100%; text-align: center; color: white; font-size: 12pt;"><img src="Resources/logo.png" style="margin-left: 0; margin-bottom: 0; position: fixed; width: 4%; border: none; float: left; margin-top: 0.4%"><h1>Познавательный сайт</h1></span></header>
	<div style="margin: auto; margin-top: 5em; margin-bottom: 5em; width: 96%; height: 100%; background-color: rgba(0,0,0,0.5);">
	<div class="post">
	<p style="margin-bottom: 20px; text-align: center; font-size: 48pt; text-indent: 0em;">Динамическое программирование</p>
	<p>Динамическое программирование - это метод, осуществляющий поиск оптимального решения задач.
    Динамическим программированием называют особый математический метод оптимизации решений, специально приспособленный к многошаговым процессам. Многошаговый процесс - это процесс, развивающийся во времени и распадающийся на ряд «шагов». Однако метод динамического программирования используется и для решения задач, в которых время не фигурирует. Некоторые процессы распадаются на шаги естественно (например, процесс планирования хозяйственной деятельности предприятия на отрезок времени, состоящий из нескольких лет); многие процессы можно разделить на этапы искусственно.
    </p>
	</div>
	<div class="post">
    <p>Одна из особенностей метода динамического программирования состоит в том, что принятие решения по отношению к многошаговым процессам рассматривается не как единичный акт, а как целый комплекс взаимосвязанных решений. Эту последовательность взаимосвязанных решений называют стратегией. Цель оптимального планирования - выбрать стратегию, обеспечивающую получение наилучшего результата с точки зрения заранее выбранного критерия. Такую стратегию называют оптимальной. 
	</p>
	</div>
	<div class="post">
	<p>Суть метода динамического программирования состоит в том, что вместо поиска оптимального решения сразу для всей сложной задачи сначала находят оптимальные решения для нескольких более простых задач, таким образом, уменьшая количество вычислений. Другими словами: динамическое программирование - это когда сложные задачи разбиваются на более лёгкие подзадачи, после чего ищутся повторения и уже на их основе задачи решаются и максимально оптимизуются для получения наилучших результатов за наименьшее время. 
    </p>
	</div>
	<div class="post">
	<p>Одной из задач, с помощью которой можно будет наглядно продемонстрировать суть метода динамического программирования - является <font color="skyblue">задача о воришке,</font> которая будет рассмотрена ниже. 
	</p>
	</div>
	<div class="post">
	<p style="color: white; margin-top: 0; margin-bottom: 20px; text-align: center; font-size: 48pt; text-indent: 0em;">Задача о воришке и домах</p>
	<p><font color="skyblue">Задача о воришке</font> (англ. The House Robber Problem) - это теоретическая задача, по условиям которой, некий вор (в нашем случае хитрый енотик), собирается ограбить целый квартал домов, в каждом из которых стоит сигнализация. Наш енотик-воришка умеет отключать простую сигнализацию, но вот незадача! Недавно во всех домах улучшили систему защиты, теперь, когда в одном из соседних домов случаются неполадки с сигнализацией, система автоматически усиливает охрану, так что енотик-воришка не сможет войти в этот дом не включив сигнализацию. Смысл задачи в том, чтобы найти оптимальное решение по выбору домов, которые нужно ограбить воришке, чтобы получить максимальную прибыль и при этом не попасться.
	</p>
	</div>
	<div class="post">
	<p>Получается подобная задача состоит из следующих компонентов:</p>
	<ul style="text-indent: 0em;">
		<li>Есть некоторое количество домов <font color="darkorange">(то есть, массив какого-то n размера);</font></li>
		<li>В каждом доме есть есть какие-то ценности, и их стоимость во всех домах может различаться, а может и совпадать <font color="darkorange">(массив заполнен какими-то различными числовыми значениям, которые могут и повторяться, прим. houses[0] = 4, т.е. в первом "доме" находится ценностей на 4 денежные единицы);</font></li>
		<li>Если выбирается один из домов, то его соседние дома для посещения закрыты <font color="darkorange">(нельзя выбирать соседей слева и справа от выбранного элемента массива).</font></li>
		<li>При решении <font color="lime">положительная</font> прибыль, которую получит воришка должна быть больше <font color="red">упущенной</font> или равною ей, иначе решение считается <font color="skyblue">отрицательным</font> (неверным).</li>
	</ul>
	</div>
	<div class="post">
	<p>Рассмотрим простой пример решения такой задачи. Пусть у нас дано <font color="skyblue">5 домов</font> с возрастающей последовательностью стоимости ценностей в них, изобразим её следующим образом:
	</p>
	<img src="Resources/img1.png"/>
	<p>Воришка может зайти в дом только если он не был до этого в доме слева или справа от него. Поэтому, следуя самой простой логике, он начнёт с самого первого дома, пропуская затем второй и четвёртый дома, чтобы не привести в действие сигнализацию. Значит, мы получим следующую картину:
	</p>
	</div>
	<div class="post">
	<img src="Resources/img2.png"/>
	<p>Как мы можем заметить в левом верхнем углу, в итоге (англ. total) воришка смог получить <font color="lime">9 денежных единиц</font>, в результате в оставшихся домах находится имущество лишь на <font color="red">6 денежных единиц</font>, а значит выбор можно назвать <font color="skyblue">положительным.</font> Также, принимая в расчёт, что в данном случае стоимость имущества в домах неуклонно растёт от дома к дому, можно сделать вывод о том, что данное решение носит ещё и <font color="skyblue">оптимальный характер.</font> Но задачи не всегда так легко решаются, и это можно увидеть в следующем примере:</p>
	</div>
	<div class="post">
	<img src="Resources/img3.png"/>
	<p>Теперь, когда стоимость имущества существенно разница, вне зависимости от расположения домов, наш изначальный способ, в котором мы начинали с первого дома и шли пропуская дом справа, может оказаться уже не таким эффективным и правильным, убедимся в этом:</p>
	<img src="Resources/img4.png"/>
	<p>Как видим, теперь воришке удалось украсть лишь <font color="lime">6 денежных единиц</font>, а упущенная прибыль составляет <font color="red">7 денежных единиц</font>, отсюда следует, что наше решение носит скорее <font color="skyblue">отрицательный</font> характер, и требует пересмотр. Поэтому изменим наш метод решения таким образом, чтобы теперь воришка пропускал первый дом, начав со второго, и всё также пропускал дома справа от выбранных:</p>
	</div>
	<div class="post">
	<img src="Resources/img5.png"/>
	<p>Ну чтож, мы получили обратную картину: теперь воришка получит <font color="lime">7 денежных единиц</font>, упустив при этом всего <font color="red">6 денежных единиц</font>, прибыль <font color="skyblue">положительна</font>, значит задачу можно считать решённой? Да, но! То что наше решение положительно, ещё не значит что оно оптимально, а в математике оптимальность играет большую роль, и именно этим по сути и занимается динамическое программирование относящееся к предмету мат. методы. На следующей картинке мы можем увидеть, что правильное решение не всегда единственное, и всегда может присутствовать решение лучше и оптимальнее всех остальных, а иногда и вовсе несколько таких решений:
	</p>
	</div>
	<div class="post">
	<img src="Resources/img6.png"/>
	<p>При подобном выборе воришка получит максимальную прибыль, при минимальной утрате. Это ещё раз доказывает, что в нашей жизни часто присутствует несколько правильных выборов, и какие-то из них выгоднее, лучше. Но в таком случае, как же нам понять, какой путь избрать? В рамках этой задачи, мы можем задать следующие вопросы:</p>
	<ol style="text-indent: 0em;">
		<li>Но если домов большое множество, а не всего-лишь 5 штук?</li>
		<li>Как быть, если стоимость ценностей в домах будет сильно скакать, не придерживаясь никакой чёткой последовательности?</li>
	</ol>
	<p>На помощь приходит один из видов метода динамического программировния - <font color="skyblue">метод решения снизу-вверх:</font></p>
	</div>
	<div class="post">
	<p>Взгляните на эту диаграмму, где каждая подзадача показана только один раз. Это цепочка зависимостей задач. Если две разные проблемы зависят (базируются) от одной и той же подпроблемы, то на нее будут указывать две стрелки.
	</p>
	<img src="Resources/img7.png" style="border: none; margin-left: 10.5%;"/>
	<p>Такая точка зрения позволяет сделать сразу несколько важных заключений. Прежде всего, у нас есть O(n) подпроблем. Кроме того, эта диаграмма является направленным ациклическим графом, что означает:</p>
	<ul style="text-indent: 0em;">
		<li>Есть узлы (задачи) и ребра (зависимости между ними);</li>
		<li>Рёбра имеют направление, одна подзадача зависит от другой;</li>
		<li>Нет циклов, значит нельзя начать с одной подзадачи и, следуя по стрелкам, вернуться к ней же.</li>
	</ul>
	</div>
	<div class="post">
	<p>В направленном ациклическом графе можно упорядочить вершины таким образом, что если пройти через них по очереди, вы будете всегда следовать направлению стрелок. Практически это означает, что можно расставить подзадачи таким образом, чтобы всегда иметь нужный результат еще до того, как он понадобится в более крупной задаче.</p>
	<p>Есть еще одна важная вещь, которую мы можем вывести из этой диаграммы. Каждая подзадача зависит только от двух других. Если вы вычисляете F(n), то вам нужны только результаты F(n-1) и F(n-2), и совершенно не нужно F(n-10). То есть вы можете спокойно выбрасывать значения, которые не участвуют в текущем вычислении.</p>
	<p>Самый первый и важный шаг в решении любой задачи динамического программирования – определение подпроблем.</p>
	<p>Для любого i-того дома есть две альтернативы:</p>
	<ul style="text-indent: 0em;">
		<li>Ограбить дом. Но после этого увеличить выгоду вы можете только в доме i-2, так как i-1 теперь для вас закрыт. В этом случае к текущей сумме добавляется значение Vi.</li>
		<li>Пропустить его. Теперь вы можете переходить к дому i-1, он доступен для ограбления. Но к текущей сумме ничего не добавляется.</li>
	</ul>
	</div>
	<div class="post">
	<p>Необходимо четко оформить вышеизложенные размышления в виде функции со следующими свойствами:</p>
	<ul style="text-indent: 0em;">
		<li>Она должна идентифицироваться по некоторым целочисленным входным данным. Это позволит связать вход с вычисленным результатом и выполнять вычисления в определенном порядке;</li>
		<li>Решение должно быть легко извлекаемо, иначе функция не имеет для нас никакой пользы;</li>
		<li>Функция должна основываться сама на себе.</li>
	</ul>
	<p>Это рекуррентное отношение – выражение одних членов последовательности через другие.
	</p>
	</div>
	<div class="post">
	<p>Таким образом, мы получаем следующую формулу для задачи о воришке:</p>
	<img src="Resources/img8.png"/>
	<p>f(i) – это максимальная прибыль, которую можно получить, ограбив дома с 0 по i. В конечном итоге мы получим значение f(n-1), где n – количество домов в квартале (если индексы начинаются с 0).</p>
    <p>Если построить граф соотношений подзадач, то мы получим ту самую диаграмму с прошлой картинки. Каждый узел f(i) здесь зависит только от двух предыдущих: f(i-1) и f(i-2). Кроме того существует n подзадач: от f(0) до f(n-1). Следовательно мы можем решить проблему за O(n) времени, используя O(1) памяти. Другими словами – вычисляя подзадачи в порядке увеличения индекса и сохраняя два последних результата, выбирая затем наибольший из них.</p>
	</div>
	<div class="post">
    <p style="margin-bottom: 20px; text-align: center; font-size: 48pt; text-indent: 0em;">Калькулятор для решения задачи о воришке</p>
    <div class="calc"><p>1) Для решения задачи задайте количество домов (до 9999, но знайте что сумму в каждом доме придётся вводить Вам самим): <input id="input1" maxlength="4" style="width: 3em; height: 1em; font-size: 1em; border: 3px solid black; text-align: center;"><img src="Resources/house.png" style="margin-left: 10px; margin-bottom: 0; width: 3.5%; border: none;"></p> <p>2) После того как вы задали количество домов, вводите стоимость ценностей для каждого дома, нажимая Enter после каждого ввода суммы - Стоимость ценностей в <span id="houseID" style="color: red;">x</span> доме: <input id="input2" maxlength="4" style="width: 3em; height: 1em; font-size: 1em; border: 3px solid black; text-align: center;"><img src="Resources/money.png" style="margin-left: 10px; margin-bottom: 0; width: 3.5%; border: none;"></p>
    	<p id="houses_val">3) Вводимые Вами суммы: </p><p id="answer">4) Итоговый ответ - Максимально возможная прибыль при Ваших условиях: </p>
    </div>
    </div>
    </div>
    <footer><span style="width: 100%; text-align: center; color: white; font-size: 12pt;"><h4>г. Новосибирск 2020 год.</h4></span></footer>
    <script src="Resources/jquery-3.5.1.min.js"></script>
	<script src="Resources/viewportchecker.js"></script>
    <script type="text/javascript" src="Resources/Script.js"></script>
</body>
</html>